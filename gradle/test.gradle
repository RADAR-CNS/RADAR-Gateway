sourceSets {
    integrationTest {
        kotlin {
            compileClasspath += main.output
            runtimeClasspath += main.output
            srcDir 'src/integrationTest/kotlin'
        }
    }
}

configurations {
    integrationTestCompile.extendsFrom testCompile
    integrationTestRuntime.extendsFrom testRuntime
    integrationTestRuntimeOnly.extendsFrom testRuntimeOnly
}

repositories {
    maven { url 'http://packages.confluent.io/maven/' }
}

dependencies {
    testCompile group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: junitVersion
    testCompile group: 'org.mockito', name: 'mockito-core', version: mockitoVersion
    testCompile group: 'com.squareup.okhttp3', name: 'mockwebserver', version: okhttp3Version
    testRuntimeOnly group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: junitVersion

    integrationTestImplementation group: 'org.radarcns', name: 'radar-schemas-commons', version: radarSchemasVersion
    integrationTestImplementation group: 'org.radarcns', name: 'radar-commons-testing', version: radarCommonsVersion
    integrationTestImplementation group: 'org.radarcns', name: 'oauth-client-util', version: radarMpVersion
}

compileTestKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

compileIntegrationTestKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

task integrationTest(type: Test) {
    description = "Run integration tests (located in src/integrationTest/...)."
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath

    testLogging.events "skipped", "failed", "passed"
}

//---------------------------------------------------------------------------//
// Testing                                                                   //
//---------------------------------------------------------------------------//

tasks.matching { it instanceof Test }.all {
    def stdout = new LinkedList<String>()
    beforeTest { TestDescriptor td ->
        stdout.clear()
    }

    useJUnitPlatform ()

    onOutput { TestDescriptor td, TestOutputEvent toe ->
        stdout.addAll(toe.getMessage().split('(?m)$'))
        while (stdout.size() > 1000) {
            stdout.remove()
        }
    }

    afterTest { TestDescriptor td, TestResult tr ->
        if (tr.resultType == TestResult.ResultType.FAILURE) {
            println()
            print("${td.className}.${td.name} FAILED")
            if (stdout.empty) {
                println(" without any output")
            } else {
                println(" with last 1000 lines of output:")
                println('=' * 100)
                stdout.each { print(it) }
                println('=' * 100)
            }
        }
    }

    testLogging {
        showExceptions = true
        showCauses = true
        showStackTraces = true
        exceptionFormat "full"
    }
}
